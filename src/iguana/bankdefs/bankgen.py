#!/usr/bin/env python3

"""
Reads an input JSON data model file, which defines the bank schema, and
generates C++ source code for handling these banks in Iguana.
"""

import sys, json, textwrap

# parse arguments
if(len(sys.argv) < 3):
    print(f'USAGE {__file__} [INPUT_JSON] [OUTPUT_BASENAME]')
    exit(2)
input_file_name = sys.argv[1]
output_base_name = sys.argv[2]

# return a comma if `idx` does not point to the last element of list `arr`
def trailing_comma(arr, idx):
    if(idx < len(arr)):
       return ','
    else:
       return ''

# map `type` character to C++ type
type_dict = {
    'B': 'int',
    'S': 'int',
    'I': 'int',
    'F': 'float',
    'D': 'double',
    'L': 'long',
}

# all iguana banks should have this group ID
iguana_group_id = 30000

# open the JSON file
with open(input_file_name) as input_file:

    try:
        bank_defs = json.load(input_file)

        # start the output C++ files
        out_h  = open(f'{output_base_name}.h', 'w')
        out_cc = open(f'{output_base_name}.cc', 'w')

        # start the header file with some common structs
        out_h.write(textwrap.dedent('''\
        #include <vector>
        #include <string>

        namespace iguana {

          /// A bank column
          struct BankColDef {
            /// @brief the name of the column
            std::string name;
            /// @brief the type of the column
            std::string type;
          };

          /// The definition of a bank
          struct BankDef {
            /// @brief the name of the bank
            std::string name;
            /// @brief the group ID of the bank
            int group;
            /// @brief the item ID of the bank
            int item;
            /// @brief the set of columns
            std::vector<BankColDef> entries;
          };

          /// Definitions of banks that Iguana algorithms may create; this variable is
          /// defined in code generated by `src/iguana/bankdefs/bankgen.py`
          extern std::vector<BankDef> const BANK_DEFS;

        }

        '''))

        # the `.cc` source file will define `BANK_DEFS`; start its definition
        out_cc.write(textwrap.dedent(f'''\
        #include "BankDefs.h"

        namespace iguana {{
          std::vector<BankDef> const BANK_DEFS = {{
        '''))

        # loop over bank definitions in the JSON file
        i_bank_def = 0
        unique_item_ids = []
        for bank_def in bank_defs:

            i_bank_def += 1
            trail_bank_def = trailing_comma(bank_defs, i_bank_def)

            # make sure the item ID is unique and the group ID is a expected
            if(bank_def["item"] in unique_item_ids):
                print(f'ERROR: item ID {bank_def["item"]} is not unique in {input_file_name}', file=sys.stderr)
                exit(1)
            unique_item_ids.append(bank_def["item"])
            if(bank_def["group"] != iguana_group_id):
                print(f'ERROR: all group IDs must be {iguana_group_id}', file=sys.stderr)
                exit(1)

            # append this bank to `BANK_DEFS`
            out_cc.write(textwrap.indent(textwrap.dedent(f'''\
            {{
              .name    = "{bank_def["name"]}",
              .group   = {bank_def["group"]},
              .item    = {bank_def["item"]},
              .entries = {{
            '''), '    '))
            i_entry = 0
            for entry in bank_def['entries']:
                i_entry += 1
                trail_entry = trailing_comma(bank_def['entries'], i_entry)
                out_cc.write(f'        {{ .name = "{entry["name"]}", .type = "{entry["type"]}" }}{trail_entry}\n')
            out_cc.write(f'      }}\n')
            out_cc.write(f'    }}{trail_bank_def}\n')

            # make a struct for this algorithm's action function output
            algo_name      = bank_def["algorithm"]
            namespace_name = '::'.join(['iguana', *algo_name.split('::')[0:-1]])
            struct_name    = algo_name.split('::')[-1] + 'Vars'
            out_h.write(textwrap.dedent(f'''\
            namespace {namespace_name} {{
              /// Set of variables created by creator algorithm `iguana::{algo_name}`
              struct {struct_name} {{
            '''))
            for entry in bank_def['entries']:
                if entry["type"] in type_dict:
                    out_h.write(textwrap.indent(textwrap.dedent(f'''\
                    /// @brief {entry["info"]}
                    {type_dict[entry["type"]]} {entry["name"]};
                '''), '    '))
                else:
                    print(f'ERROR: bank entry type "{entry["type"]}" is unknown', file=sys.stderr)
                    exit(1)
            out_h.write('  };\n')
            out_h.write('}\n\n')

        out_cc.write('  };\n')
        out_cc.write('}\n')
        out_cc.close()
        out_h.close()

    except json.decoder.JSONDecodeError:
        print(f'ERROR: failed to parse {input_file_name}; check its JSON syntax', file=sys.stderr)
        exit(1)

# for ext in ['h', 'cc']:
#     print(f'Generated {output_base_name}.{ext}')
