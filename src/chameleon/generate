#!/usr/bin/env ruby

require 'yaml'
require 'optparse'
require 'ostruct'
require 'fileutils'

@args = OpenStruct.new
@args.action_yaml = ''
@args.verbose = false

##################################################################################

class Logger

  def initialize(verbose)
    @verbose = verbose
  end

  def error(msg)
    $stderr.puts "[ERROR]: #{msg}"
    exit 1
  end

  def verbose(msg)
    puts msg if @verbose
  end

end

##################################################################################

OptionParser.new do |o|
  o.banner = "USAGE: #{$0} [OPTIONS]..."
  o.separator ''
  o.separator 'OPTIONS:'
  o.on('-i', '--input [ACTION_YAML]', 'action function specification YAML') {|a| @args.action_yaml = a}
  o.separator ''
  o.on('-v', '--verbose') {|a| @args.verbose = true}
  o.on_tail('-h', '--help', 'show this message') do
    puts o
    exit
  end
end.parse! ARGV
@log = Logger.new @args.verbose
@log.verbose "OPTIONS: #{@args}"

##################################################################################

# open action function specification
@log.error "option '--input' needs a value" if @args.action_yaml.empty?
@log.verbose "parsing #{@args.action_yaml}"
@log.error "input file '#{@args.action_yaml}' does not exist" unless File.exists? @args.action_yaml
main_spec = YAML.load_file @args.action_yaml

# get a specification (a yaml node value)
def get_spec(node, *path)
  def get_node(node, path, full_path)
    return node if path.empty?
    key = path.shift
    @log.error "failed to find node '#{full_path.join ' : '}' in #{@args.action_yaml}" unless node.has_key? key
    get_node node[key], path, full_path
  end
  get_node(node, path.clone, path.clone)
end

# check if the function type is known
def check_function_type(name, type)
  error("action function '#{name}' has unknown type type '#{type}'") unless ['filter', 'transformer', 'creator'].include? type
end

# parse algorithm info
algo_name = get_spec main_spec, 'algorithm', 'name'
@log.verbose "algorithm name: #{algo_name}"

# generate c-bindings
# FIXME: move to its own file
class Bindings_c

  def initialize(out_name, algo_name, log)
    @log = log
    @log.verbose "generating C bindings '#{out_name}'"
    @out = File.open out_name, 'w'
    @algo_name = algo_name
    @out.puts <<~END_CODE
      // C functions to provide action function bindings for Fortran

      /////////////////////////////////////////
      //  WARNING: DO NOT EDIT THIS FILE     //
      //  it has been generated by chameleon //
      /////////////////////////////////////////

      #include "../Algorithm.h"
      #include "iguana/algorithms/Bindings.h"

      // clang-format off
      namespace iguana::bindings::#{@algo_name} {
        extern "C" {
    END_CODE
  end

  def bind(spec)
    ftn_name = get_spec spec, 'name'
    ftn_type = get_spec spec, 'type'
    @log.verbose " - bind #{ftn_type} function #{@algo_name}::#{ftn_name}"
    check_function_type "#{@algo_name}::#{ftn_name}", ftn_type

    ### docstring
    @out.puts <<~END_CODE.gsub(/^/,'  ')

      /// @see `iguana::#{@algo_name}::#{ftn_name}`
      /// @param [in] algo_idx the algorithm index
    END_CODE
    get_spec(spec, 'inputs').each do |input|
      @out.puts "  /// @param [in] #{input}"
    end
    case ftn_type
    when 'filter'
      @out.puts <<~END_CODE.gsub(/^/,'  ')
        /// @param [in,out] out the filter return value; if this value is already set, the
        /// result will be the `AND` of the initial value and this filter
      END_CODE
    end

    ### function parameters
    @out.puts <<~END_CODE.gsub(/^/,'  ')
      void iguana_#{@algo_name.downcase.gsub /::/, '_'}_#{ftn_name.downcase}_(
        algo_idx_t* algo_idx,
    END_CODE
    get_spec(spec, 'inputs').each do |input|
      @out.puts "    #{get_spec input, 'type'}* #{get_spec input, 'name'},"
    end
    case ftn_type
    when 'filter'
      @out.puts "    bool* out)"
    end

    ### function body
    @out.puts "  {"
    case ftn_type
    when 'filter'
      @out.puts <<~END_CODE.gsub(/^/,'    ')
        *out = *out && dynamic_cast<iguana::#{@algo_name}*>(iguana_get_algo_(algo_idx))->#{ftn_name}(
          #{get_spec(spec, 'inputs').map{|i|"*#{get_spec i, 'name'}"}.join ', '});
      END_CODE
    end
    @out.puts "  }"

  end

  def close
    @out.puts <<~END_CODE
        }
      }
      // clang-format on
    END_CODE
    @out.close
  end
end

# make output files
algo_dir = File.dirname @args.action_yaml
@log.error "directory '#{algo_dir}' does not exist" unless Dir.exists? algo_dir
out_dir = File.join algo_dir, '.chameleon'
FileUtils.mkdir_p out_dir, verbose: @args.verbose
out_files = {
  :c_bindings => Bindings_c.new(File.join(out_dir, 'bind.cc'), algo_name, @log),
}

# parse action functions
get_spec(main_spec, 'actions').each do |action_spec|
  out_files[:c_bindings].bind action_spec
end

# close output files
out_files.values.each &:close
