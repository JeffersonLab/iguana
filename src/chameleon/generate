#!/usr/bin/env ruby

require 'yaml'
require 'optparse'
require 'ostruct'
require 'fileutils'

@args = OpenStruct.new
@args.algo_dir = ''
@args.verbose = false

##################################################################################

class Logger

  def initialize(verbose)
    @verbose = verbose
  end

  def error(msg)
    $stderr.puts "[ERROR]: #{msg}"
    exit 1
  end

  def verbose(msg)
    puts msg if @verbose
  end

end

##################################################################################

OptionParser.new do |o|
  o.banner = "USAGE: #{$0} [OPTIONS]..."
  o.separator ''
  o.separator 'OPTIONS:'
  o.on('-a', '--algorithm [ALGORITHM_DIR]', 'algorithm source code directory') {|a| @args.algo_dir = a}
  o.separator ''
  o.on('-v', '--verbose') {|a| @args.verbose = true}
  o.on_tail('-h', '--help', 'show this message') do
    puts o
    exit
  end
end.parse! ARGV
@log = Logger.new @args.verbose
@log.verbose "OPTIONS: #{@args}"

##################################################################################

# open action function specification
@log.error "option '--algorithm' needs a value" if @args.algo_dir.empty?
@action_yaml_name = File.join @args.algo_dir, 'Action.yaml'
@log.verbose "parsing #{@action_yaml_name}"
@log.error "file '#{@action_yaml_name}' does not exist" unless File.exists? @action_yaml_name
main_spec = YAML.load_file @action_yaml_name

# get a specification (a yaml node value)
def get_spec(node, *path)
  def get_node(node, path, full_path)
    return node if path.empty?
    key = path.shift
    @log.error "failed to find node '#{full_path.join ' : '}' in #{@action_yaml_name}" unless node.has_key? key
    get_node node[key], path, full_path
  end
  get_node(node, path.clone, path.clone)
end

# parse algorithm info
algo_name = get_spec main_spec, 'algorithm', 'name'
@log.verbose "algorithm name: #{algo_name}"

# generate c-bindings
# FIXME: move to its own file
class Bindings_c

  def initialize(out_name, algo_name, log)
    @log = log
    @log.verbose "generating C bindings '#{out_name}'"
    @out = File.open out_name, 'w'
    @algo_name = algo_name
    @out.puts <<~END_CODE
    /////////////////////////////////////////
    //  WARNING: DO NOT EDIT THIS FILE     //
    //  it has been generated by chameleon //
    /////////////////////////////////////////
    #include "../Algorithm.h"
    #include "iguana/algorithms/Bindings.h"

    namespace iguana::bindings::#{@algo_name} {
      extern "C" {
    END_CODE
  end

  def close
    @out.puts <<~END_CODE
      }
    }
    END_CODE
    @out.close
  end
end

# make output files
out_dir = File.join @args.algo_dir, '.chameleon'
FileUtils.mkdir_p out_dir, verbose: @args.verbose
out_files = {
  :c_bindings => Bindings_c.new(File.join(out_dir, 'bind.cc'), algo_name, @log),
}

# parse action functions
# get_spec(main_spec, 'actions').each do |action_spec|
#   out_files[:c_bindings].action_function action_spec
# end

# close output files
out_files.values.each &:close
