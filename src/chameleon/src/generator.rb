class Generator

  RESULT_VAR = 'result' # the name of the result of an action function call

  def initialize(out_name='', algo_name='', description: '', generator_name: '')
    @out_name    = out_name
    @out_dir     = File.dirname @out_name
    @algo_name   = algo_name
    @algo_header = File.join *@algo_name.split('::'), 'Algorithm.h'
    @log_tag     = generator_name.empty? ? "[chameleon]" : "[chameleon::#{File.basename generator_name, '.rb'}]"
    @ftn_type    = nil
    unless out_name.empty?
      verbose "generating #{description} '#{@out_name}'"
      @out = File.open @out_name, 'w'
    end
  end

  # accessors/modifiers
  attr_accessor :out_name

  # print an error and exit
  def error(msg, quit=true)
    $stderr.puts "#{@log_tag} [ERROR]: #{msg}"
    exit 1 if quit
  end

  # print a log message
  def verbose(msg)
    puts "#{@log_tag} #{msg}" if VERBOSE
  end

  # get a specification (a yaml node value)
  def get_spec(node, *path, default: nil)
    def get_node(node, path, full_path, default)
      return node if path.empty?
      key = path.shift
      unless node.has_key? key
        return default unless default.nil?
        error "failed to find node '#{full_path.join ' : '}' in #{ACTION_YAML}", false unless node.has_key? key
        error "this happened when searching the following sub-tree:", false
        $stderr.puts "#{node.to_yaml}"
        $stderr.puts '---'
        error "please check this YAML file to see if something is missing or if you have a typo."
      end
      get_node node[key], path, full_path, default
    end
    get_node node, path.clone, path.clone, default
  end

  # let `spec_params` be a specification tree of action function parameters,
  # found at `node[key]`. This method "maps" its elements (i.e.,
  # "spec_params.map") by yielding a block with parameters |name, type, cast, dimension|
  # NOTE: `get_scalar_type` is used to get the fundamental type, for parameters with dimension > 0
  def map_spec_params(node, key)
    spec_params = get_spec node, key
    spec_params.map do |var|
      name = ''
      if key == 'outputs' and spec_params.size == 1 and !var.has_key?('name') # single, anonymous output
        name = RESULT_VAR
      else
        name = get_spec var, 'name'
        error "don't name your variable '#{name}', since this name is reserved" if name == RESULT_VAR
        name = "#{RESULT_VAR}_#{name}" if @ftn_type == 'transformer' and key == 'outputs'
      end
      type      = get_scalar_type(get_spec var, 'type') # get the fundamental type
      cast      = get_spec var, 'cast', default: ''
      dimension = get_spec var, 'dimension', default: 0
      yield name, type, cast, dimension
    end
      .compact
  end

  # check if the function type is known
  def check_function_type(name, type)
    error("action function '#{name}' has unknown type type '#{type}'") unless ['filter', 'transformer', 'creator'].include? type
  end

  # function to get the scalar type, e.g. `get_scalar_type('std::vector<int>') => 'int'`
  def get_scalar_type(type)
    type.split('<').last.split('>').first
  end

  # function for generating C++ code to convert a C-array to C++ `std::vector`
  def gen_array_to_vector(name_array, type, cast)
    type_in     = type
    type_out    = cast.empty? ? type_in : cast
    name_vector = "#{name_array}__vector"
    elem        = "#{name_array}[i]"
    vector_type = type_out=='bool' ? 'std::deque' : 'std::vector' # use `deque<bool>` insead of forbidden `vector<bool>`
    result = <<~END_CODE
      #{vector_type}<#{type_out}> #{name_vector};
        for(std::size_t i = 0; i < std::extent_v<decltype(#{name_array})>; i++)
          #{name_vector}.push_back(#{cast.empty? ? elem : "#{cast}(#{elem})"});
      END_CODE
    result.chomp
  end

  # function for generating C++ code to convert a C++ `std::vector` to a C array
  def gen_vector_to_array(name_vector, type, cast)
    type_in    = cast.empty? ? type : cast
    type_out   = type
    name_array = "#{name_vector}__array"
    elem       = "#{name_vector}.at(i)"
    result = <<~END_CODE
      #{type_out} *#{name_array} = new #{type_out}[#{name_vector}.size()];
        for(decltype(#{name_vector})::size_type i = 0; i < #{name_vector}.size(); i++)
          #{name_array}[i] = #{cast.empty? ? elem : "#{type_out}(#{elem})"};
      END_CODE
    result
  end

  # deter developers from editting the generated files
  def deterrence_banner(lang)
    case lang
    when 'c'
      result = <<~EOS
        // =====================================================
        //  WARNING: DO NOT EDIT THIS FILE
        //  - it has been generated by chameleon
        //  - if you really want to edit this file, consider
        //    instead editting chameleon itself
        // =====================================================
        EOS
    else
      error "deterrence_banner does not know the language '#{lang}'"
    end
    result
  end

end
